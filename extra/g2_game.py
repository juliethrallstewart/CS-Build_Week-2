# -*- coding: utf-8 -*-
"""Copy of Copy of Lambda Treasure Hunt - CS BW2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gwqumho2KVLEPFEgp3_FAngXOELN8liR

# Lambda Treasure Hunt - CS BW2

https://github.com/gyhou/CS-Build-Week-2
---
**Overview**

You start the adventure unworthy, unequipped and anonymous. Your first task is to traverse the island and build a map for your personal use. Along the way, you will discover equipment, treasure and clues which will assist you on your quest for power, wealth and glory.

To efficiently traverse an island maze, collect treasure, solve puzzles, unearth powerful artifacts and more.

Glory and riches await the victors!

# Build a map

## Empty Map
"""

# graph = {}

"""## Complete Road Map

- 500 rooms
- Shop: 1 (Sell treasures for gold)
- Pirate Rye: 467 (Exchange 1000g to change name)

### After changing name
- Wishing Well: 55 (Get clue for mining location)
- Shrines: 22, 374, 461, 491 (Unlock abilities)
"""

# Upload graph file
from graph import graph as graph
len(graph)

"""# Initialization"""

import json
import time
import random
import requests
# Upload token
# with open('george_token', 'r') as auth_token:
#   token = auth_token.read()
token = 'b27e6856e5d217203ce3c7ac456e3882a46da1be'

def init(token):
  url = 'https://lambda-treasure-hunt.herokuapp.com/api/adv/init/'
  result = requests.get(url, 
                         headers={'Authorization': f'Token {token}'}).json()
  time.sleep(15)
  if len(result['errors']) > 0:
    print(result['errors'])                   b    
  if result['room_id'] not in graph:
    new_room = {}
    for direction in result['exits']:
        new_room[direction] = "?"
    graph[result['room_id']] = [new_room, result]
  return result
    
current = init(token)
print(current, "CURRENT")
current

"""# Status, Inventory"""

def status_check():
  url = 'https://lambda-treasure-hunt.herokuapp.com/api/adv/status/'
  result = requests.post(url, 
                         headers={'Content-Type':'application/json',
                                  'Authorization': f'Token {token}'}).json()
  if len(result['errors']) > 0:
    print(result['errors'])   
  return result
# status_check()

"""## Equipment

- Bodywear: Increase strength
- Footwear: Increase speed
"""

def equip_item(item_name):
  url = 'https://lambda-treasure-hunt.herokuapp.com/api/adv/wear/'
  data = f'{{"name":"{item_name}"}}'
  result = requests.post(url, data=data,
                         headers={'Content-Type':'application/json',
                                  'Authorization': f'Token {token}'}).json()
  if len(result['errors']) > 0:
    print(result['errors'])                  
  print(result)
  return result     
# equip_item('well-crafted jacket')

"""# Actions

- Movement (move, fly, dash, recall, warp)
- Treasure (take/sell)
- Pray (gain abilitie)
- Mine (Coin)

## Movement

- Move, Fly, Dash, Recall, Warp

### Breathe First Search

- Finds the shortest path to the destination

#### Qeue Class
"""

# Helper class
class Queue():
  def __init__(self):
      self.queue = []
  def enqueue(self, value):
      self.queue.append(value)
  def dequeue(self):
      if self.size() > 0:
          return self.queue.pop(0)
      else:
          return None
  def size(self):
      return len(self.queue)

"""#### BFS"""

def bfs(starting_room, destination):
  queue = Queue()
  queue.enqueue([starting_room])
  visited = set()
  while queue.size() > 0:
    path = queue.dequeue()
    room_id = path[-1]
    if room_id not in visited:
      if room_id == destination:
        return path
      else:
        for direction in graph[room_id][0]:
          # if graph[room_id][0][direction] != "?":
            new_path = path.copy()
            new_path.append(graph[room_id][0][direction])
            queue.enqueue(new_path)
      visited.add(room_id)
  return []

# Test
# bfs(current['room_id'], 55), bfs(0, 55)

current

"""### Move/Fly

- One room traversal
- Base 15s CD

#### Basic movement

Move - no buff or penalty

**Wise Explorer Buff**

- Predict the destination room id to reduce CD by 50%


---


After obtaining **Fly** ability

Buffs
- Instant CD when going downhill
- -10% CD in normal rooms

Penalty
- +10s CD in CAVE terrains
"""

# Movement
def movement(direction, next_room_id=None):
  if graph[current['room_id']][1]['terrain'] == 'CAVE':
    url = 'https://lambda-treasure-hunt.herokuapp.com/api/adv/move/'
  else:
    # Once you acquire flying ability
    url = 'https://lambda-treasure-hunt.herokuapp.com/api/adv/fly/'
  if next_room_id is not None:
    data = f'{{"direction":"{direction}","next_room_id": "{next_room_id}"}}'
    if graph[next_room_id][1]['terrain'] == 'CAVE':
      url = 'https://lambda-treasure-hunt.herokuapp.com/api/adv/move/'
  else:
    data = f'{{"direction":"{direction}"}}'
  
  result = requests.post(url, data=data,
                         headers={'Content-Type':'application/json',
                                  'Authorization': f'Token {token}'}).json()
  if len(result['errors']) > 0:
    print(result['errors'])
  # Update room_id in graph
  # inverse_directions = {"n": "s", "s": "n", "e": "w", "w": "e"}
  # if result['room_id'] not in graph:
  #   graph[result['room_id']] = {}
  #   for road in result['exits']:
  #     graph[result['room_id']][road] = "?"
  #   new_room = {}
  #   for road in result['exits']:
  #     new_room[road] = "?"
  #   graph[result['room_id']] = [new_room, result]
  # graph[current['room_id']][0][direction] = result['room_id']
  # graph[result['room_id']][0][inverse_directions[direction]] = current['room_id']
  # print(result)
  return result

"""### Dash

After obtaining **Dash** ability
- Cover many rooms in one direction quickly
- 15s CD + 0.5s CD for each room dashed
"""

def dash(direction, num_rooms, next_room_ids):
  url = 'https://lambda-treasure-hunt.herokuapp.com/api/adv/dash/'
  next_room_ids = [str(room_id) for room_id in next_room_ids]
  next_room_ids = ','.join(next_room_ids)
  data = f'{{"direction":"{direction}","num_rooms":"{num_rooms}","next_room_ids":"{next_room_ids}"}}'
  print(data)
  result = requests.post(url, data=data,
                         headers={'Content-Type':'application/json',
                                  'Authorization': f'Token {token}'}).json()
  if len(result['errors']) > 0:
    print(result['errors'])                  
  print(result)
  return result

"""### Recall

- Recall to your starting location Room_id : 0
- Base 15s CD
"""

def recall():
  url = 'https://lambda-treasure-hunt.herokuapp.com/api/adv/recall/'
  result = requests.post(url, headers={'Content-Type':'application/json',
                                       'Authorization': f'Token {token}'})
  return result.json()
current = recall()

"""## Treasure

- Pick up treasures to sell at shop to gain gold
- Player can hold up to player's [strength stats] items
- When a player's inventory is full +100% CD
- Tiny, Small, Shiny, Great, Amazing, Spectacular, Dazzling, Brilliant, Sparkling
- Use for transmogrify
"""

# Take treasure
def take_item(treasure):
  url = 'https://lambda-treasure-hunt.herokuapp.com/api/adv/take/'
  data = f'{{"name":"{treasure}"}}'
  result = requests.post(url, data=data,
                         headers={'Content-Type':'application/json',
                                  'Authorization': f'Token {token}'}).json()
  if len(result['errors']) > 0:
    print(result['errors'])
  else:
    print(f'Taking {treasure}!')
  return result
# take_item('shiny treasure')

# Sell Treasure
def sell_item(treasure):
  url = 'https://lambda-treasure-hunt.herokuapp.com/api/adv/sell/'
  data = f'{{"name":"{treasure}", "confirm":"yes"}}'
  result = requests.post(url, data=data,
                         headers={'Content-Type':'application/json',
                                  'Authorization': f'Token {token}'}).json()
  print(f'Selling {treasure} to shop.\n{result}')
  return result

"""### Manual selling treasures"""

# time.sleep(current['cooldown'])
# items = status_check()['inventory']
# for item in items:
#   if 'treasure' in item:
#     current = sell_item(item)
#     time.sleep(current['cooldown'])

"""## Name Change

Pirate Rye (467) - Use 1000g to change name to unlock abilities and pray
"""

def name_change(new_name):
  url = 'https://lambda-treasure-hunt.herokuapp.com/api/adv/change_name/'
  data = f'{{"name":"{new_name}", "confirm":"aye"}}'
  result = requests.post(url, data=data,
                         headers={'Content-Type':'application/json',
                                  'Authorization': f'Token {token}'}).json()
  print(f'Changing name to {new_name}!')
  return result
# name_change('Jon Doe')

"""## Pray at Shrine

Need to change name first to pray and unlock abilities
- 22 - Fly: Good for all terrains except cave.
- 374 - Warp: Must be have both bodywear and footwear equipped to warp.
- 461 - Dash: Cover many rooms in one direction quickly
- 492 - Recall: Recall to starting Room[0]
"""

def pray():
  url = 'https://lambda-treasure-hunt.herokuapp.com/api/adv/pray/'
  result = requests.post(url, headers={'Content-Type':'application/json',
                                       'Authorization': f'Token {token}'})
  return result.json()
# pray()

"""## Transmogrify

Room 495

- Trade One item and one Lambdacoin for an bodywear or footwear item

**Different grades of items**
- Appalling, Terrible, Poor, Nice, Well-crafted, Exquisite
"""

def transmogrify(item_name):
  url = 'https://lambda-treasure-hunt.herokuapp.com/api/adv/transmogrify/'
  data = f'{{"name":"{item_name}"}}'
  result = requests.post(url, data=data,
                         headers={'Content-Type':'application/json',
                                  'Authorization': f'Token {token}'}).json()
  return result
# transmogrify('great treasure')

"""# BFS Map Traversal"""

def map_traversal(current_room, destination, pick_item=False):
  # Recall or walk?
  recall_path = bfs(0, destination)
  base_path = bfs(current_room['room_id'], destination)
  if len(recall_path) + 2 < len(base_path):
    print('RECALLING to Room[0]!')
    end_room = recall()
    base_path = recall_path
    time.sleep(end_room['cooldown'])
  # Base path = list of room_ids to traverse to destination
  print(f'Heading to the Room[{destination}].. {base_path}')
  while len(base_path) > 1:
    path_exits = graph[base_path[0]][0]
    for direction, room_id in path_exits.items():
      if room_id == base_path[1]:
        # Figure out the direction of next room
        next_move = direction
        break
    # How many rooms available to Dash?
    next_room_ids = []
    if len(base_path) > 3:
      next_room_ids.append(base_path[1])
      for index in range(1,len(base_path)):
        # If direction the same, add to list
        if next_move in graph[base_path[index]][0]:
          if graph[base_path[index]][0][next_move] == base_path[index+1]:
            next_room_ids.append(base_path[index+1])
          # If not, stop the loop
          else:
            break
        else:
          break
    # Check length of eligible rooms to Dash
    if len(next_room_ids) > 3:
      print(f'Dash - Room[{current_room["room_id"]}] {next_move} to {next_room_ids}')
      end_room = dash(next_move, len(next_room_ids), next_room_ids)
      base_path = base_path[len(next_room_ids):]
    # If not, move normally
    else:
      print(f'Room[{current_room["room_id"]}] to Room[{path_exits[next_move]}]')
      end_room = movement(next_move, path_exits[next_move])
      base_path.pop(0)
    print(f"CD: {end_room['cooldown']}, {end_room['messages']}")
    
    
    quality = ['sparkling','brilliant','dazzling','spectacular','amazing','great','shiny']
    if pick_item:
      if len(end_room['items']) > 0:
        print(f'{end_room["items"]} found in Room[{end_room["room_id"]}]')
        for item in end_room['items']:          
          item_grade = item.split(' ')[0]
          if item_grade in quality:
            time.sleep(end_room['cooldown'])
            end_room = take_item(item)
    current_room = end_room
    time.sleep(current_room['cooldown'])
  return current_room

"""## BFS Destination"""

# import random
current = init(token)
# time.sleep(current['cooldown'])
time.sleep(15)

wishing_well = 55
transmogriphier_room = 495
pirate_rye = 467
# while True:
# room_num = random.randint(20,499)
current = map_traversal(current, wishing_well, True)

"""# Lambda Coin

## Examine Well for clue

- Room 55
- Decipher clue to get mining room location
"""

def wishing_well():
  url = 'https://lambda-treasure-hunt.herokuapp.com/api/adv/examine/'
  data = f'{{"name":"Well"}}'
  result = requests.post(url, data=data,
                         headers={'Content-Type':'application/json',
                                  'Authorization': f'Token {token}'}).json()
  if len(result['errors']) > 0:
    print(result['errors'])                              
  print(result['description'])
  return result
message = wishing_well()
message

message

"""## Decipher Message"""

# import ls8 CPU
from ls8cpu import *
def msg_decode(message):
  split_msg = message.split('.')[3]
  with open('test.txt', 'w') as output:
    output.write(split_msg)
  cpu.load('test.txt')
  decode_msg = cpu.run()
  join_msg = "".join(decode_msg)
  mining_room_id = int(''.join(i for i in join_msg if i.isdigit()))
  print(join_msg)
  return mining_room_id
msg_decode(message['description'])

"""## Blockchain Proof"""

def get_last_proof():
  url = 'https://lambda-treasure-hunt.herokuapp.com/api/bc/last_proof/'
  result = requests.get(url, 
                        headers={'Content-Type':'application/json',
                                 'Authorization': f'Token {token}'}).json()
  return result
# get_last_proof()

def proof_of_work(last_proof, current_level):
    """
    Get the last valid proof to use to mine a new block. 
    Also returns the current difficulty level, which is the number of 0's 
    required at the beginning of the hash for a new proof to be valid.
    The proof of work algorithm for this blockchain is 
    not the same as we used in class.
    """
    start = timer()
    print(f"\nLast proof: {last_proof} -- Searching for next proof..\n")
    proof = 1000000
    while valid_proof(last_proof, proof, current_level) is False:
      proof += 1
    print(f"Proof found: {proof} in {timer() - start:.3f}s")
    return proof

import hashlib
def valid_proof(last_proof, proof, current_level):
    """
    Does hash(last_proof, proof) contain N leading zeroes, 
    where N is the current difficulty level?
    Use sha256 in hashlib
    """
    guess = f"{last_proof}{proof}".encode()
    guess_hash = hashlib.sha256(guess).hexdigest()

    return guess_hash[:current_level] == "0"*current_level

def mine_coin(new_proof):
  url = 'https://lambda-treasure-hunt.herokuapp.com/api/bc/mine/'
  data = f'{{"proof":{new_proof}}}'
  result = requests.post(url, data=data,
                         headers={'Content-Type':'application/json',
                                  'Authorization': f'Token {token}'}).json()
  return result

"""## Mining Coin"""

from timeit import default_timer as timer
current = init(token)
time.sleep(current['cooldown'])

# Get the last proof from the server
current_proof = get_last_proof()
time.sleep(1)
proof = current_proof['proof']
current_level = current_proof['difficulty']

new_proof = proof_of_work(proof, current_level)
reponse = mine_coin(new_proof)
print(reponse)
time.sleep(reponse['cooldown'])

reponse

"""## Check Coin Balance"""

def coin_balance():
  url = 'https://lambda-treasure-hunt.herokuapp.com/api/bc/get_balance/'
  result = requests.get(url, 
                        headers={'Content-Type':'application/json',
                                 'Authorization': f'Token {token}'}).json()
  return result
coin_balance()

"""# Automate Mining"""

from timeit import default_timer as timer
current = init(token)
time.sleep(current['cooldown'])
# Run forever until interrupted
while True:
  # Head to wishing well 55
  current_room = map_traversal(current, 55, True)
  # get message
  message = wishing_well()
  time.sleep(message['cooldown'])
  # decode
  mine_room_id = msg_decode(message['description'])
  # head to decoded location
  current_room = map_traversal(current_room, mine_room_id, True)
  current = graph[mine_room_id][1]
  # mine
  while True:
    # Get the last proof from the server
    current_proof = get_last_proof()
    time.sleep(1)
    proof = current_proof['proof']
    current_level = current_proof['difficulty']

    new_proof = proof_of_work(proof, current_level)
    reponse = mine_coin(new_proof)
    print(reponse)
    time.sleep(reponse['cooldown'])
    if reponse['messages'] == ['New Block Forged']:
      break

"""# Traversal"""

inverse_directions = {"n": "s", "s": "n", "e": "w", "w": "e"}
# prev_move = None
while True:
  current_exits = graph[current['room_id']][0]
  # directions = []
  # for direction, room_id in current_exits.items():
  #   # If adjacent room_id not visited yet, add that direction
  #   if room_id == "?":
  #     directions.append(direction)
  # if len(directions) == 0:
    # print('All adjacent rooms visited..')
  destination = 161
  targets = bfs(current['room_id'], destination)
  print(f'Heading to Room[{destination}].. {len(destination)} rooms left')
  for direction, room_id in current_exits.items():
    if room_id == targets[0]:
      # Figure out the direction of next room
      next_move = direction
      break
  # Dashing..
  # next_room_ids = [targets[0]]
  # for index in range(len(targets)):
  #   if graph[targets[index]][0][next_move] == targets[index+1]:
  #     next_room_ids.append(targets[index+1])
  #   else:
  #     break
  # else:
  #   next_move = random.choice(directions)
  # if len(next_room_ids) > 1:
  #   print(f'Dashing.. {next_move} to {next_room_ids}')
  #   end_room = dash(next_move, len(next_room_ids), next_room_ids)
  # else:
  print(f'Room[{current["room_id"]}] to Room[{current_exits[next_move]}]')
# if current_exits[next_move] == "?":
#   print(f"Traveling to the unknown.. ({len(graph)}/500)")
#   end_room = movement(next_move)
# else:
  # Use "Wise Explorer" buff
  end_room = movement(next_move, current_exits[next_move])
  print(f"CD: {end_room['cooldown']}, {end_room['messages']}")
  # if len(end_room['items']) > 0:
  #   for item in end_room['items']:
  #     if 'treasure' not in item:
  #       print(f'{item} found in {end_room["room_id"]}')
  #       time.sleep(end_room['cooldown'])
  #       end_room = take_item(item)
  # if end_room['title'] == 'Shop':
  #   time.sleep(end_room['cooldown'])
  #   items = status_check()['inventory']
  #   for item in items:
  #     if 'treasure' in item:
  #       time.sleep(end_room['cooldown'])
  #       end_room = sell_item(item)
  # prev_move = next_move
  if len(end_room['errors']) > 0:
    print(f"Error: {end_room['errors']}")
    break
  current = end_room
  time.sleep(current['cooldown'])